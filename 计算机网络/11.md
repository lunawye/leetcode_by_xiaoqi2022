# 计网篇










# 10.三种保持会话的方式

（一）session机制保持会话
1. 存在的问题
- 高并发情况下，会占用服务器大量内存
- 分布式（一个业务分成几个子业务，部署在多个服务器）或者集群（一个业务部署在多个服务器）的时候，session不能共享。
2. 解决方案
- 高并发的时候可以将session存储到redis，如果用户长时间没有访问，将session存储到redis，就减少了服务器的压力。
- 分布式或者集群的时候，先通过redis来判断用户状态也可以实现session共享.

（二）cookie机制保持会话
1. 使用的方法
- **登录验证后，创建登录凭证**（比如：用户id+登录时间+过期时间），
- 将登录凭证进行加密（为了避免暴露信息），加密后写到浏览器的cookie，
- 以后，每次请求都发送cookie，服务器根据对应的解密算法对其进行验证
- （或者将加密过的cookie内容存储到数据库，请求服务器的时候，服务器在数据库进行查找）。
2. 存在的问题
- 每次访问都提交cookie，增加请求量
- 其他访问可能需要cookie（比如说购物车的信息存放在cookie），
- 浏览器对每个域存储的cookie的大小有限制，那么需要控制加密后的凭证。

（三）token机制保持会话
1. 使用方法
- **cookie 和session依赖于浏览器，如果客户端不是浏览器，那么需要手动添加token**
- （和cookie类似，也是登录凭证），将token添加到http header或者做为参数添加到url。
2. 存在的问题
- 每次访问的时候手动添加token
- 和cookie 的方式一样增加了请求量
---
总结
1. 不同的方式适合不同的应用场景，视情况使用。
2. 相同点
- 所有的方式目的都是为了验证用户状态。
- 都需要在客户端存储凭证。
3. 不同点
- 第一种是通过是通过空间换时间，消耗内存存储session对象，但是判断用户状态不用复杂的逻辑。
- 第二种第三种用时间换空间，在服务器端逻辑处理进行判断用户状态。


# 11.TCP三次握手原因、过程、失败以及不采用三次握手的后果

- 如果第三次握手的ACK传输失败，导致服务端迟迟没有收到ACK，就会释放资源，
- 这时候客户端认为自己已经连接好了，就会给服务端发送数据，
- 服务端由于没有收到第三次握手，就会以RST包对客户端响应。
- 但是实际上服务端会因为没有收到客户端的ACK多次发送SYN+ACK，次数是可以设置的，
- 如果最后还是没有收到客户端的ACK，则释放资源。

# 12.Cookie和Session的区别

**相同点：cookie和session都是用来跟踪浏览器用户身份的会话方式。**

二、工作原理：\
1.Cookie的工作原理\
（1）浏览器端第一次发送请求到服务器端\
（2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端\
（3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie\
（4）服务器端通过Cookie中携带的数据区分不同的用户


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdccee7012c04fb895ae35c84dd5f0eb~tplv-k3u1fbpfcp-watermark.image?)

一、session的概念及特点
- session概念:在计算机中，尤其是在网络应用中，称为“会话控制”。
- Session 对象存储特定用户会话所需的属性及配置信息。
- 说白了session就是一种可以维持服务器端的数据存储技术。

session主要有以下的这些特点：
- session保存的位置是在服务端
- session一般来说要配合cookie使用，如果用户浏览器禁用了cookie，
- 那么只能使用URL重写来实现session的存储功能
- 单纯的使用session来存储用户回话信息，那么当用户量较多时，session文件数量会很多，会存在session查询慢的问题

**本质上：session技术就是一种基于后端有别于数据库的临时存储技术**

二、为什么要使用session
- 我们目前使用的互联网应用层协议基本上都是基于 HTTP 和 HTTPS 的，它们的本身是无状态的，只负责请求和响应。 
- 我告诉服务器我需要什么，服务器返回给我相应的资源。
- 如果没有额外处理的话，服务器是不知道你是谁，更无法根据你是谁给你展现和你相关的内容了。
- HTTP 协议一开始被设计成这样还是有一些历史原因的，当时的互联网多用于学术交流，
- 只用于文章信息的展现之类的事情，远没有现在这么丰富多彩。
- 所以在当时的背景下 HTTP 协议被设计成这样其实也是很符合它的场景的。
- 但随着互联网应用越来越广泛，应用的形式也变得越来越多，
- 我们的 Web 应用不只限于提供简单的信息展现了，还需要用户能够登录，可以在论坛发帖子，在购物网站买东西等等。 
- 这就需要 HTTP 协议能够记录用户的状态。也就是我们现在熟悉的 Session 由来。

**四、session的生命周期**\
**Session何时生效：**
- Sessinon在用户访问第一次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建
- Session，只访问HTML、IMAGE等静态资源并不会创建Session,可调request.getSession(true)强制生成Session。

**Session何时失效：**
- 1.服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。
- Tomcat中Session的默认失效时间为20分钟。
- 从session不活动的时候开始计算，如果session一直活动，session就总不会过期。
- 从该Session未被访问,开始计时; 一旦Session被访问,计时清0;
- 关闭浏览器，session就会失效


**五、session的性能瓶颈**
- 另外一个要聊聊的就是 Session数据的存储。 
- 通常情况下，如果你不明确的设置，大多数 Web 框架会把 Session数据存放到内存中。如果你的 Web 应用用户量不大的话，这也不成问题。 但如果你的用户数比较大的话，就可能发生一个事情 — 内存不够用了。
- 这很正常，内存容量是非常宝贵的，假设每个用户的 Session 数据是 100K， 1万个用户就会大概占用 1G 的存储空间，如果你的 Session 数据清理机制也恰巧比较慢的话，内存非常容易被占满。这就需要你在设计比较大并发量的站点时，要考虑 Session 的存储方式，比如把它们保存到硬盘文件系统中，或者数据库中。 
- 所以你在开发一个 Web 应用的时候，如果你的用户量很大，你需要有这个意识。另外 Session 放到内存中还有一个弊端，如果你的 Web 服务器发生重启，那么所有的 Session 状态都会被情况，会在一定程度上影响用户体验。

**六、session实现登录状态的控制**
- 假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下：
- 用户再次访问时，tomcat在会话对象中查看登录状态。
- 每次请求受保护资源时都会检查会话对象中的登录状态，
- 只有 isLogin=true 的会话才能访问，登录机制因此而实现。

**四、区别对比：**\
(1)cookie数据存放在客户的浏览器上，session数据放在服务器上\
(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session\
(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE\
(4)单个cookie在客户端的限制是4K，就是说一个站点在客户端存放的COOKIE不能超过4K。\
(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中


# 13.ajax请求，和普通的http url请求，有什么不一样？

ajax的请求，多了一个 **“X-Requested-With”** 属性。


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/314c253f1aba4cccba26476963b6c88b~tplv-k3u1fbpfcp-watermark.image?)
# 14.TCP和UDP的区别
- TCP是面向连接的，而UDP是无连接的
- TCP是可靠的，它确保数据完整无误地按序到达，而UDP是不可靠的，它不会去备份数据，也不关心对方是否接收到数据。
- UDP没有拥塞控制，一直以恒定的速率发送数据，即使网络条件不好，也不进行速率调整，因此在网络条件不好的情况下可能会造成丢包
- TCP是一对一的，而UDP可以一对一，一对多，多对一，多对多。

# 14.计算机网络的五层模型

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7aaa34c9ee4f1baaa57e02ae7c4751~tplv-k3u1fbpfcp-watermark.image?)

**1. 物理层**\
物理层是有关于光纤，电缆，双绞线的物理实现部分，单纯负责0，1传送。\
**2. 数据链路层**\
**数据链路层**工作在物理层之上，负责给这些0，1制定传送的规则，然后另一方再按照相应的规则来进行解读。\
**2.1 以太网协议**\
以太网协议规定，一组电信号构成一个数据包，把这个数据包称之为“桢”。每一个桢由**标头(Head)** 和**数据(Data)** 两部分组成。如下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1772af2297d4c8998b08ee755d06f64~tplv-k3u1fbpfcp-watermark.image?)\
这个桢的最大长度是1518个字节，最小长度为64字节。假如需要传送的数据很大的话，就分成多个桢来进行传送。\
表头部分：主要是一些说明数据，例如发送者，接收者等信息。固定长度18字节。\
数据部分：是这个数据包具体的，想给接受的内容。

**2.2 MAC地址**\
计算机与计算机之间的唯一标识：MAC地址\
连入网络的每一个计算机都会有**网卡**接口，每一个网卡都会一个地址，这个地址就叫做**MAC地址**。计算机之间的数据传送，就是通过MAC地址来唯一寻找、传送的。MAC地址在网卡生产是就被唯一标识了。\

**2.3 广播与ARP协议**

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830c04ac66054b67b7639eb3dd3dc6e1~tplv-k3u1fbpfcp-watermark.image?)

广播：计算机A是通过广播的方式把数据发送给计算机B。在同一个子网中，计算机A要向计算机B发送一个数据包，这个数据包包含接收者的MAC地址。这个时候同一个子网中的计算机C,D也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的MAC地址取出来，与自身的MAC地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。这种发送方式我们称之为广播。\

ARP协议：通过它我们可以知道子网中其他计算机的MAC地址。\

**3.网络层**\
**网络层：区分MAC地址是否处于同一个子网中。**\
子网：假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给**网关**，让网关进行转发。\

**3.1 IP协议**\
IP协议有两种版本，一种是IPv4,另一种是IPv6。不过我们目前大多数用的还是IPv4，我们现在也只讨论IPv4这个版本的协议。\
这个IP地址由32为的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255\
这个IP地址被分为两部分，前面一部分代表**网络部分**，后面一部分代表**主机部分**。并且网络部分和主机部分的二进制位数是不固定的。\
假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是**处于同一个子网**中。

子网掩码：子码掩码和IP地址一样也是32位二进制数，不过它的网络部分规定全部为1，主机部分规定全部为0。\
知道了子码掩码，相当于我们知道了网络部分是几位，主机部分是几位。我们只需要把IP地址与它的子码掩码做与(and)运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。\

**3.2 ARP协议**\
有了两台计算机的IP地址，我们就可以判断出它们是否处于同一个子网之中。 假如他们处于同一个子网之中，计算机A要给计算机B发送数据时。我们可以通过ARP协议来得到计算机B的MAC地址。\
ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。这样，计算机A就能知道计算机B的MAC地址了。

**3.3 DNS服务器**\
DNS服务器——解析ip地址

**4. 传输层**\
传输层：传输层的功能就是建立**端口到端口**的通信。相比网络层的功能是建立**主机到主机**的通信。\
将数据成功传输给接收方时，只是将数据从一个主机传送给了另一个主机，还要判断是接收方的哪个应用接收了数据。此时通过**端口**来判断。也就是说，我们在从计算机A传数据给计算表B的时候，还得指定一个端口，以供特定的应用程序来接受处理。

也就是说，有了IP和端口，我们就可以进行通信了。这个时候可能有人会说，我输入IP地址的时候并没有指定一个端口啊。其实呢，对于有些传输协议，已经有设定了一些默认端口了。例如http的传输默认端口是80，这些端口信息也会包含在数据包里的。

5. **应用层**
应用层：用来规定应用程序的数据格式，将各种各样的数据格式（html，MP4等）转化为我们能够解读的格式。

资料参考：[聊一聊计算机网络的五层模型 - 简书 (jianshu.com)](https://www.jianshu.com/p/ad820267da1c)
# 15. TCP三次握手的过程？
# 16. 第一次握手的SYN报文中有哪些信息？（seq、ack）
# 17. 这个序列号seq是如何生成的？（随机生成、向后移动）
# 18. 每一次往后移动seq，会有什么问题？（会被猜出来seq，伪造连接）
# 19. TCP半连接队列里面会记录什么信息？（TCP控制块，里面存储了连接状态等信息）
# 20. TCP和UDP的区别？
