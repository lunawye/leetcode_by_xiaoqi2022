1、在main执行之前和之后执行的代码可能是什么？
main函数执行之前，主要就是初始化系统相关资源：

设置栈指针

初始化静态static变量和global全局变量，即.data段的内容

将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容

全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码

将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数

main函数执行之后：

全局对象的析构函数会在main函数之后执行；

可以用 atexit 注册一个函数，它会在main 之后执行;

2、结构体内存对齐问题？
结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。

未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）

3、指针和引用的区别
指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名

指针可以有多级，引用只有一级

指针可以为空，引用不能为NULL且在定义时必须初始化

指针在初始化后可以改变指向，而引用在初始化之后不可再改变

sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小

当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。

引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。

引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。

不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

参考代码：

void test(int *p)
{
　　int a=1;
　　p=&a;
　　cout<<p<<" "<<*p<<endl;
}

int main(void)
{
    int *p=NULL;
    test(p);
    if(p==NULL)
    cout<<"指针p为NULL"<<endl;
    return 0;
}
//运行结果为：
//0x22ff44 1
//指针p为NULL



void testPTR(int* p) {
    int a = 12;
    p = &a;

}

void testREFF(int& p) {
    int a = 12;
    p = a;

}
void main()
{
    int a = 10;
    int* b = &a;
    testPTR(b);//改变指针指向，但是没改变指针的所指的内容
    cout << a << endl;// 10
    cout << *b << endl;// 10

    a = 10;
    testREFF(a);
    cout << a << endl;//12
}
4、堆和栈的区别
申请方式不同：栈由系统自动分配；堆是自己申请和释放的。

申请大小限制不同：栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。

形象的比喻

栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

《C++中堆（heap）和栈(stack)的区别》：https://blog.csdn.net/qq_34175893/article/details/83502412

5、区别以下指针类型？
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。

int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。

int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。

int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间
首先整理一下虚函数表的特征：

虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成

虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：

虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

《虚函数表存放在哪里》：https://blog.csdn.net/u013270326/article/details/82830656

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区

C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。

7、new / delete 与 malloc / free的异同
相同点

都可用于内存的动态申请和释放

不同点

前者是C++运算符，后者是C/C++语言标准库函数

new自动计算要分配的空间大小，malloc需要手工计算

new是类型安全的，malloc不是。例如：

int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用

后者需要库文件支持，前者不用

new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

8、new和delete是如何实现的？
new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针

delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存

9、malloc和new的区别？
malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。

malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。

malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

delete和delete[]区别？

delete只会调用一次析构函数。

delete[]会调用数组中每个元素的析构函数。

10、宏定义和函数有何区别？
宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。

宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。

宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。

宏定义不要在最后加分号。