


# 11.纯虚函数与抽象类
包含纯虚函数的类被称为抽象类

```cpp
class <类名>
{
    virtual <类名> <函数名> (<参数表>) = 0;
}
```
纯虚函数的作用是在基类中为派生类保留一个函数的名字，以便派生类根据需要对它进行定义。\
参考资料：[谈谈你对虚函数的理解_浮生流年的博客-CSDN博客_如何理解虚函数](https://blog.csdn.net/qq_40945965/article/details/79576740)
# 12.为什么要引用抽象基类和纯虚函数
<1>为了方便使用多态性\
<2>在很多情况下，基类本身生成对象是不合理的。例如：动物作为一个基类可以派生出老虎、狮子等子类，但动物本身生成对象明显不合常理。抽象基类不能够被实例化，它定义的纯虚函数相当于接口，能把派生类的共同行为提取出来。\
参考资料：[谈谈你对虚函数的理解_浮生流年的博客-CSDN博客_如何理解虚函数](https://blog.csdn.net/qq_40945965/article/details/79576740)
# 13.虚函数与纯虚函数的区别
<1>虚函数是实现的，哪怕是空实现；纯虚函数只是一个接口，是函数声明，需要子类去实现\
<2>虚函数在子类中也可以不修改；但纯虚函数必须在子类中实现\
<3>虚函数的类用于“实作继承”，也就是说继承接口的同时也继承了父类的实现，当然也可以完成自己的实现；纯虚函数的类用于“介面继承”，即纯虚函数关注的是接口统一性，实现由子类完成\
<4>带纯虚函数的类叫虚基类（抽象类），这种类不能直接实例化对象，只有被继承，并实现其纯虚函数后，才能使用

---

虚函数与纯虚函数 在他们的子类中都可以被重写。它们的区别是：\
（1）纯虚函数只有定义，没有实现；而虚函数既有定义，也有实现的代码。\
  纯虚函数一般没有代码实现部分，如\
```cpp
virtual void print() = 0;
```
  而一般虚函数必须要有代码的实现部分，否则会出现函数未定义的错误。\
（2）包含纯虚函数的类不能定义其对象，而包含虚函数的则可以。
```cpp
virtual void print()
{   printf("This is virtual function\n");  }
```

  （1）类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。\
  （2）虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像Java的接口一样。通常把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。\
  （3）虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。\
  （4）带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。\
  参考资料：
  1. [什么是虚函数,什么是纯虚函数?为什么引入虚函数和纯虚函数?_千么漾漾的博客-CSDN博客](https://blog.csdn.net/qq_41786318/article/details/79601101)
  2. [谈谈你对虚函数的理解_浮生流年的博客-CSDN博客_如何理解虚函数](https://blog.csdn.net/qq_40945965/article/details/79576740)
 # 14.运算符重载/函数重载对比虚函数和纯虚函数的优缺点
 <1>运算符重载和函数重载\
静态关联：关联工作在编译、链接阶段完成，在此期间，系统就可以根据函数的参数类型和参数个数决定调用哪个同名函数。\
静态关联的优缺点：程序执行效率高，但对程序员水平要求较高

<2>虚函数和纯虚函数\
动态关联：关联工作在程序运行阶段完成。\
动态关联的优缺点：提供更好的编程灵活性、问题抽象性和程序的易维护性，但是函数调用速度慢\
参考资料：[谈谈你对虚函数的理解_浮生流年的博客-CSDN博客_如何理解虚函数](https://blog.csdn.net/qq_40945965/article/details/79576740)

 # 15.降低延迟和抖动的方案
 网络中的延迟是指信息从发送到接收经过的延迟时间，一般由传输延迟及处理延迟组成；而抖动是指最大延迟与最小延迟的时间差，如最大延迟是20毫秒，最小延迟为5毫秒，那么网络抖动就是15毫秒，它主要标识一个网络的稳定性。\
 一、网络抖动：
1. 定义：抖动是QOS里面常用的一个概念，其意思是指分组延迟的变化程度。
2. 产生原因：如果网络发生拥塞，排队延迟将影响端到端的延迟，并导致通过同一连接传输的分组延迟各不相同，而抖动，就是用来描述这样一延迟变化的程度。
二、网络延迟：
1. 定义：网络延迟是在传输介质中传输所用的时间，即从报文开始进入网络到它开始离开网络之间的时间。
2. 产生原因：网络延迟是指各式各样的数据在网络介质中通过网络协议(如TCP/IP)进行传输，如果信息量过大不加以限制，超额的网络流量就会导致设备反应缓慢，造成网络延迟。

一、解决网络延迟的方法：
1. 提升WAN性能，通过选择较短和更有效率的路由路径、部署低延迟的交换机和路由设备、主动避免网络设备停机时间，WAN运营商也可以对降低延迟作出贡献。
2. 增加WAN带宽能提高应用程序的性能，在实践中，运用能够更有效利用现有WAN带宽的各种技术同样可以提升WAN应用程序的性能。
二、解决网络抖动的方法：
1. 数据包接收端的**抖动缓存指针队列**的入队线程接收数据包，对接收到的数据包进行排序后将接收到的数据包插入抖动缓存指针队列的相应位置
2. 抖动缓存指针队列的**出队线程定时器**以一定时间间隔触发出队线程，出队线程判断抖动缓存指针队列队头的数据包是否应该在当前触发时刻出队，如果是，则将该数据包出队。
参考资料：[网络中的抖动和延迟是什么？怎么产生的？_百度知道 (baidu.com)](https://zhidao.baidu.com/question/539357558.html)

# 16.NULL,0,nullptr的区别分析
在编写C程序的时候只看到过NULL，而在C++的编程中，我们可以看到NULL和nullptr两种关键字，其实nullptr是C++11版本中新加入的，它的出现是为了解决NULL表示空指针在C++中具有二义性的问题，为了弄明白这个问题，我查找了一些资料，总结如下。

一、C程序中的NULL\
在C语言中，NULL通常被定义为：#define NULL ((void *)0)\
所以说NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。

```cpp
int  *pi = NULL;
char *pc = NULL;
```
二、C++程序中的NULL

但是问题来了，以上代码如果使用C++编译器来编译则是会出错的，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：
```cpp
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```
可见，在C++中，NULL实际上是0,而不是(void*)0,因为C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了结果空指针的表示问题，C++引入了0来表示空指针，这样就有了上述代码中的NULL宏定义。\
但是实际上，用NULL代替0表示空指针在函数重载时会出现问题，程序执行的结果会与我们的想法不同，举例如下：

```cpp
#include <iostream>
using namespace std;
 
void func(void* i)
{
	cout << "func1" << endl;
}
 
void func(int i)
{
	cout << "func2" << endl;
}
 
void main(int argc,char* argv[])
{
	func(NULL);
	func(nullptr);
	getchar();
}
```

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78624491558e48bba3d1d1e5f2cc5e15~tplv-k3u1fbpfcp-watermark.image?)


在这段代码中，我们对函数func进行可重载，参数分别是void*类型和int类型，但是运行结果却与我们使用NULL的初衷是相违背的，因为我们本来是想用NULL来代替空指针，但是在将NULL输入到函数中时，它却选择了int形参这个函数版本(因为NULL定义为0)，所以是有问题的，这就是用NULL代替空指针在C++程序中的二义性。

三、C++中的nullptr

为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，从上面的例子中我们可以看到，使用nullptr作为实参，确实选择了正确的以void*作为形参的函数版本。

总结：

1. NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。
2. 所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。
参考资料：
1. [史上最明白的 NULL、0、nullptr 区别分析（老师讲N篇都没讲明白的东东），今天终于明白了，如果和我一样以前不明白的可以好好的看看... - porter_代码工作者 - 博客园 (cnblogs.com)](https://www.cnblogs.com/porter/p/3611718.html)
2. [C++中NULL和nullptr的区别_天涯明月刀的博客-CSDN博客_nullptr和null区别](https://blog.csdn.net/qq_18108083/article/details/84346655)


# 17.哈希表插入时间复杂度
哈希表插入的时间复杂度与冲突次数有关，O(冲突次数/n)，最好的情况冲突次数为0,直接插入，时间复杂度为O(1)。最坏情况是所有值对应同一个键值，这是冲突次数最多，为0+1+2+3+4+…+(n-1)=n*(n-1)/2,平均比较次数为(n-1)/2,时间复杂度为O(n)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8c8c086911a47069e89ce6c75a0f7b6~tplv-k3u1fbpfcp-watermark.image?)

参考资料：[以下数据结构说法，错误的是___?_阿里巴巴笔试题_牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/5ca2d1e6b8ca42c9a1406af5f302c5bf#:~:text=%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8F%92%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E5%86%B2%E7%AA%81%E6%AC%A1%E6%95%B0%E6%9C%89%E5%85%B3%EF%BC%8CO%20%28%E5%86%B2%E7%AA%81%E6%AC%A1%E6%95%B0%2Fn%29%EF%BC%8C%E6%9C%80%E5%A5%BD%E7%9A%84%E6%83%85%E5%86%B5%E5%86%B2%E7%AA%81%E6%AC%A1%E6%95%B0%E4%B8%BA0%2C%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO%20%281%29%E3%80%82%20%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E6%98%AF%E6%89%80%E6%9C%89%E5%80%BC%E5%AF%B9%E5%BA%94%E5%90%8C%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%EF%BC%8C%E8%BF%99%E6%98%AF%E5%86%B2%E7%AA%81%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%EF%BC%8C%E4%B8%BA0%2B1%2B2%2B3%2B4%2B%E2%80%A6%2B,%28n-1%29%3Dn%2A%20%28n-1%29%2F2%2C%E5%B9%B3%E5%9D%87%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0%E4%B8%BA%20%28n-1%29%2F2%2C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO%20%28n%29)

# 18. 什么情况下必须使用C++的初始化列表
理论而言：

1. 初始化 != 赋值. 
a. 初始化代表为变量分配内存. 变量在其定义处被编译器初始化(编译时). 在函数中, 函数参数初始化发生在函数调用时(运行时). \
b. 赋值代表"擦除对象当前值, 赋予新值". 它不承担为对象分配内存的义务.

2. C++中, 类成员的初始化于初始化列表中完成, 先于构造函数体执行. 即成员真正的初始化发生在初始化列表中, 而不是构造函数体中.

再给说明。
1. 如果类中有一个成员是一个引用, 由于引用必须给予初始值, 因此, 引用必须使用初始化列表.
2. 同理, const属性必须给予初始值, 必须使用初始化列表.	
3. 继承类中调用基类初始化构造函数, 实际上就是先构造基类对象, 必须使用初始化列表.

别的不再说明, 什么时候必须使用初始化列表是很明显的；
另外, 简单的说, 任何时候都鼓励使用初始化列表, 一些别的事情(比如在构造函数中分配资源之类的, 请参考RAII, Resource Acquizition Is Initialization)可以放在构造函数体内完成.

参考资料：[什么情况下必须使用C++的初始化列表_WingC的博客-CSDN博客_c++什么时候用初始化列表](https://blog.csdn.net/wingwc/article/details/77290139)

# 19.智能指针的引用计数放在哪的
堆上，不是堆上的话一个可能就是不同对象进行check，多次判零，多次释放，内存泄漏

参考资料：[c++智能指针的引用计数是存放在栈上还是堆上呢？_技术交流_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/231223?type=1)
# 20.红黑树
线性查找 —性能低—>二分查找— 二查叉树会出现退化成链表的问题—>出现AVL平衡二叉树—数据变化有频繁更新节点问题—>出现红黑树
**什么是红黑树？**
红黑树（Red Black Tree）是一颗自平衡（self-balancing）的二叉排序树（BST），树上的每一个结点都遵循下面的规则（特别提醒，这里的自平衡和平衡二叉树AVL的高度平衡有别）：
1.  每一个结点都有一个颜色，要么为红色，要么为黑色；
2.  树的根结点为黑色；
3.  树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；
4.  从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。
参考资料：[什么是红黑树，一篇文章解决所有疑惑~~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143585797)

# 21.智能指针
C++11 引入了 3 个智能指针类型：

1.  `std::unique_ptr<T>` ：独占资源所有权的指针。
2.  `std::shared_ptr<T>` ：共享资源所有权的指针。
3.  `std::weak_ptr<T>` ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。
std::auto_ptr已被废弃。

## **std::unique_ptr**

简单说，当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。这是很基本的 RAII 思想。

std::unique_ptr 的使用比较简单，也是用得比较多的智能指针。这里直接看例子。

## **std::unique_ptr**

简单说，当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。这是很基本的 RAII 思想。

std::unique_ptr 的使用比较简单，也是用得比较多的智能指针。这里直接看例子。

1.  使用裸指针时，要记得释放内存。

```
{
    int* p = new int(100);
    // ...
    delete p;  // 要记得释放内存
}
```

1.  使用 std::unique_ptr 自动管理内存。

```
{
    std::unique_ptr<int> uptr = std::make_unique<int>(200);
    //...
    // 离开 uptr 的作用域的时候自动释放内存
}
```

1.  std::unique_ptr 是 move-only 的。

```
{
    std::unique_ptr<int> uptr = std::make_unique<int>(200);
    std::unique_ptr<int> uptr1 = uptr;  // 编译错误，std::unique_ptr<T> 是 move-only 的

    std::unique_ptr<int> uptr2 = std::move(uptr);
    assert(uptr == nullptr);
}
```
## **std::shared_ptr**

std::shared_ptr 其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。

## **std::shared_ptr 的实现原理**

一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。

shared_ptr 需要维护的信息有两部分：

1.  指向共享资源的指针。
2.  引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。

## **std::weak_ptr**

std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：

1.  如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。
2.  当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。

当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。

## **enable_shared_from_this**

一个类的成员函数如何获得指向自身（this）的 shared_ptr
成员函数获取 this 的 shared_ptr 的正确的做法是继承 std::enable_shared_from_this。

## **小结**

智能指针，本质上是对资源所有权和生命周期管理的抽象：

1.  当资源是被独占时，使用 std::unique_ptr 对资源进行管理。
2.  当资源会被共享时，使用 std::shared_ptr 对资源进行管理。
3.  使用 std::weak_ptr 作为 std::shared_ptr 管理对象的观察者。
4.  通过继承 std::enable_shared_from_this 来获取 this 的 std::shared_ptr 对象。

参考资料：
1. [现代 C++：一文读懂智能指针 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/150555165)
2. [详解C++11智能指针 - 孤独的猫 - 博客园 (cnblogs.com)](https://www.cnblogs.com/djcsch2001/p/15415172.html#:~:text=C%2B%2B%E9%87%8C%E9%9D%A2%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%3A%20auto_ptr%2C%20unique_ptr%2Cshared_ptr%2C,weak_ptr%20%E5%85%B6%E4%B8%AD%E5%90%8E%E4%B8%89%E4%B8%AA%E6%98%AFC%2B%2B11%E6%94%AF%E6%8C%81%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%BB%8F%E8%A2%ABC%2B%2B11%E5%BC%83%E7%94%A8%E3%80%82%20C%2B%2B11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D)
